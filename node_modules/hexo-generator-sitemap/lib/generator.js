'use strict';

var minimatch = require('minimatch');
var template = require('./template');

module.exports = function(locals) {
  var config = this.config;
  var skipRenderList = [
    '**/*.js',
    '**/*.css'
  ];

  if (Array.isArray(config.skip_render)) {
    skipRenderList = skipRenderList.concat(config.skip_render);
  } else if (config.skip_render != null) {
    skipRenderList.push(config.skip_render);
  }

  var posts = [].concat(locals.posts.toArray(), locals.pages.toArray())
    .filter(function(post) {
      return post.sitemap !== false && !isMatch(post.source, skipRenderList);
    })
    .sort(function(a, b) {
      return b.updated - a.updated;
    });


  var langToModifyDate = {}
  for (var i = 0; i < config.language.length; i++) {
      langToModifyDate[config.language[i]] = new Date (2017,1,1);
  }

  for (var i = 0; i < posts.length; i++) {
    if (posts[i].slug !== undefined) {
        posts[i].alternatives = [];
        for (var j = 0; j < posts.length; j++) {
            if (posts[i].slug != undefined && posts[i].slug == posts[j].slug) {
                posts[i].alternatives.push({permalink: posts[j].permalink, lang: posts[j].lang});
            }
        }
    }
    langToModifyDate[posts[i].lang] = Math.max(langToModifyDate[posts[i].lang], Math.max(posts[i].date, posts[i].updated));
  }

  for (var i = 0; i < config.language.length; i++) {
      posts.unshift({
        permalink: config.url + "/" + config.language[i] + "/archives/" + "index.html",
        date: new Date(langToModifyDate[config.language[i]]),
        lang: config.language[i]
      })
  }

  posts.unshift({
    permalink: config.url + "/index.html",
    date: new Date(2017,8,8),
    lang: "x-default"
  })

  var xml = template(config).render({
    config: config,
    posts: posts
  });

  return {
    path: config.sitemap.path,
    data: xml
  };
};

function isMatch(path, patterns) {
  if (!patterns) return false;
  if (!Array.isArray(patterns)) patterns = [patterns];
  if (!patterns.length) return false;

  for (var i = 0, len = patterns.length; i < len; i++) {
    if (minimatch(path, patterns[i])) return true;
  }

  return false;
}
